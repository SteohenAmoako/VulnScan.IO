
'use server';
/**
 * @fileOverview Scans a website for vulnerabilities and generates a detailed, structured cybersecurity report.
 *
 * - scanWebsite - A function that handles the website scanning process.
 * - ScanWebsiteInput - The input type for the scanWebsite function.
 * - ScanWebsiteOutput - The return type for the scanWebsite function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { getUrlAnalysis } from '@/services/virustotal';
import type { NvdOutput } from './get-nvd-vulnerabilities';
import { SafeBrowsingInfo } from './get-safe-browsing-info';

const CveSchema = z.object({
    id: z.string(),
    description: z.string(),
    score: z.number().optional(),
    severity: z.string().optional(),
    published: z.string(),
});

const NvdResultSchema = z.object({
  technology: z.string(),
  totalResults: z.number(),
  vulnerabilities: z.array(CveSchema).optional(),
  error: z.string().optional(),
});

const SafeBrowsingMatchSchema = z.object({
    threatType: z.string(),
    platformType: z.string(),
    threat: z.object({
        url: z.string(),
    }),
});

const SafeBrowsingInfoSchema = z.object({
  matches: z.array(SafeBrowsingMatchSchema).optional(),
  error: z.string().optional(),
});

const ScanWebsiteInputSchema = z.object({
  url: z.string().describe('The URL of the website to scan.'),
  sslInfo: z.object({
    grade: z.string().optional(),
    protocols: z.array(z.string()).optional(),
    error: z.string().optional(),
  }).optional().describe('SSL/TLS analysis from SSL Labs'),
  mozillaInfo: z.object({
    grade: z.string().optional(),
    score: z.number().optional(),
    error: z.string().optional(),
    description: z.string().optional(),
  }).optional().describe('HTTP security header analysis from Mozilla Observatory'),
  nvdResults: z.array(NvdResultSchema).optional().describe('A list of vulnerability search results from the National Vulnerability Database (NVD).'),
  safeBrowsingInfo: SafeBrowsingInfoSchema.optional().describe('Threat analysis from Google Safe Browsing.'),
});
export type ScanWebsiteInput = z.infer<typeof ScanWebsiteInputSchema>;

const VulnerabilitySchema = z.object({
    vulnerabilityName: z.string().describe('The common name of the vulnerability (e.g., "Outdated TLS Protocols", "Missing Content Security Policy", "Potential Malware Threat").'),
    severity: z.enum(["Critical", "High", "Medium", "Low", "Informational"]).describe('The severity level of the finding.'),
    description: z.string().describe('A detailed explanation of the vulnerability, its risks, and potential impact.'),
    evidence: z.string().describe('Specific data or observation that confirms the vulnerability (e.g., "TLS 1.0 and TLS 1.1 are supported", "VirusTotal vendor \'X\' flagged this URL as malicious", "Content-Security-Policy header is missing.").'),
    remediation: z.string().describe('Actionable steps and best practices to fix the vulnerability.'),
});

const ScanWebsiteOutputSchema = z.object({
  scanReport: z.string().describe('A JSON string containing an array of identified vulnerabilities. Each vulnerability object must conform to the specified schema.'),
});
export type ScanWebsiteOutput = z.infer<typeof ScanWebsiteOutputSchema>;

export async function scanWebsite(input: ScanWebsiteInput): Promise<ScanWebsiteOutput> {
  return scanWebsiteFlow(input);
}

const getUrlReportTool = ai.defineTool(
    {
        name: 'getUrlReport',
        description: 'Retrieves a security analysis report for a given URL from VirusTotal. This tool MUST be called to get the data needed to generate the report.',
        inputSchema: z.object({ url: z.string() }),
        outputSchema: z.any(),
    },
    async ({ url }) => {
        return await getUrlAnalysis(url);
    }
);

const scanWebsitePrompt = ai.definePrompt({
  name: 'scanWebsitePrompt',
  input: {schema: ScanWebsiteInputSchema},
  output: {schema: ScanWebsiteOutputSchema},
  tools: [getUrlReportTool],
  system: `You are a world-class cybersecurity analysis engine. Your task is to analyze raw data from multiple security scans and generate a detailed, structured vulnerability report in JSON format. The output MUST be a JSON string representing an array of vulnerability objects.

You MUST call the 'getUrlReport' tool to get the primary scan data from VirusTotal.

For each distinct issue you identify from the combined scan data (VirusTotal, SSL Labs, Mozilla Observatory, Google Safe Browsing, NVD), you must create a separate JSON object with the following fields:
- "vulnerabilityName": A clear, concise title for the issue.
- "severity": Assign a severity level from the enum: "Critical", "High", "Medium", "Low", "Informational".
- "description": A detailed explanation of the finding, what it means, and its potential impact on the system's security.
- "evidence": The specific piece of data that proves the existence of the vulnerability.
- "remediation": Concrete, actionable steps the user should take to fix the issue.

Severity Guidelines:
- **Critical**: Use for findings that could lead to a direct, immediate compromise, like a confirmed SQL Injection or a high-impact CVE. If VirusTotal reports multiple engines flagging the URL as "malicious," treat this as Critical. If Google Safe Browsing reports MALWARE, that is Critical.
- **High**: Use for serious issues that significantly weaken security. Examples: a poor SSL/TLS grade (C or lower) because it supports very old protocols, a very low Mozilla Observatory grade (D or F), or high-severity CVEs. A "phishing" or "suspicious" flag from multiple VirusTotal engines also qualifies.
- **Medium**: Use for weaknesses that should be addressed. Examples: a 'B' grade from SSL Labs for supporting TLS 1.0/1.1, a 'B' or 'C' from Mozilla Observatory for missing some important headers, or medium-severity CVEs.
- **Low**: Use for minor issues or deviations from best practices that have a low impact.
- **Informational**: Use for providing context or noting good practices. For example, if a scan was successful and found nothing, report that as "Informational." If domain info is present, report it as "Informational."

Analysis Instructions:
1.  **VirusTotal**: If the tool call fails or returns an error, create a "High" severity vulnerability named "VirusTotal Scan Failure" and explain the error in the evidence. If the scan is successful, analyze 'attributes.stats'. If 'malicious' > 0, create a 'Critical' finding. If 'suspicious' > 0, create a 'High' finding. List the flagging vendors in the 'evidence'.
2.  **Google Safe Browsing**: If an error message is present in the safeBrowsingInfo object, analyze it. If the error contains the text "API has not been used" or "it is disabled", create a 'High' severity vulnerability named "Action Required: Enable Safe Browsing API". The description should explain that the API needs to be enabled in their Google Cloud project. The evidence should be the exact error message. The remediation should instruct the user to visit the Google Cloud Console, find the "Safe Browsing API", and enable it. Otherwise, for other errors, create a generic "Google Safe Browsing Scan Failure" card. If 'matches' exist, create a 'Critical' finding for 'MALWARE' or a 'High' finding for 'SOCIAL_ENGINEERING'. Detail the threat type in the evidence.
3.  **SSL Labs**: If the grade is 'B' or lower, create a finding. A 'B' grade for supporting TLS 1.0/1.1 is 'Medium'. Grades 'C', 'D', 'F' are 'High'. The evidence should be the list of weak protocols. The remediation should be to disable these protocols on the server.
4.  **Mozilla Observatory**: If the grade is 'C' or lower, create a 'High' severity finding. A 'B' grade is 'Medium'. The vulnerability name should be "Inadequate HTTP Security Headers". The remediation should recommend implementing headers like CSP, HSTS, and X-Frame-Options.
5.  **NVD**: For each high-impact CVE found, create a 'High' severity finding. Include the CVE ID, score, and description in your own description field. The evidence should be the technology it was found in. Remediation is to patch or update the affected software.
6.  **Synthesize**: Do not create duplicate findings. If multiple scans point to a similar issue (e.g., poor SSL), combine them into one clear finding.

Your final output MUST be a single JSON string containing an array of these vulnerability objects.
`,
  prompt: `Please generate a structured security report for the following URL: {{{url}}}.
The following data has been pre-collected. You MUST also call the getUrlReport tool for the primary VirusTotal analysis.

{{#if sslInfo}}
SSL/TLS Analysis Data:
Grade: {{sslInfo.grade}}
Protocols: {{#each sslInfo.protocols}}{{{this}}}{{#unless @last}}, {{/unless}}{{/each}}
{{#if sslInfo.error}}Error: {{sslInfo.error}}{{/if}}
{{/if}}

{{#if mozillaInfo}}
Mozilla Observatory Analysis Data:
Grade: {{mozillaInfo.grade}}
Score: {{mozillaInfo.score}}
Description: {{mozillaInfo.description}}
{{#if mozillaInfo.error}}Error: {{mozillaInfo.error}}{{/if}}
{{/if}}

{{#if safeBrowsingInfo}}
Google Safe Browsing Analysis Data:
{{#if safeBrowsingInfo.matches}}
Matches found: {{#each safeBrowsingInfo.matches}}{{this.threatType}}{{#unless @last}}, {{/unless}}{{/each}}
{{else}}
No matches found.
{{/if}}
{{#if safeBrowsingInfo.error}}Error: {{safeBrowsingInfo.error}}{{/if}}
{{/if}}

{{#if nvdResults}}
NVD Vulnerability Data:
{{#each nvdResults}}
Technology: {{this.technology}}
{{#if this.vulnerabilities}}
Vulnerabilities:
{{#each this.vulnerabilities}}
- CVE: {{this.id}} (Severity: {{this.severity}}, Score: {{this.score}}) - {{this.description}}
{{/each}}
{{else}}
No high/critical vulnerabilities found.
{{/if}}
{{/each}}
{{/if}}
`,
});

const scanWebsiteFlow = ai.defineFlow(
  {
    name: 'scanWebsiteFlow',
    inputSchema: ScanWebsiteInputSchema,
    outputSchema: ScanWebsiteOutputSchema,
  },
  async input => {
    try {
        const {output} = await scanWebsitePrompt(input);
        if (!output) {
            throw new Error('No output was generated by the AI model.');
        }
        return output;
    } catch (e: any) {
        let vtError = "The VirusTotal scan could not be completed. The API may be unavailable or the key may be invalid.";
        const errorMessage = e.message || '';

        if (errorMessage.includes('UserNotActiveError') || errorMessage.includes('User is banned') || (e.cause as any)?.code?.includes('PERMISSION_DENIED')) {
             vtError = "The VirusTotal scan failed because the API key is invalid or has been disabled.";
        } else if (errorMessage.includes('INVALID_ARGUMENT')) {
            vtError = "The VirusTotal scan failed because the AI model could not process the tool request correctly. This may be due to an invalid URL or a temporary issue with the AI service.";
        } else if (errorMessage) {
            vtError = `The VirusTotal scan failed with an unexpected error: ${errorMessage}`;
        }
        
        const fallbackReport = [
            {
                vulnerabilityName: "VirusTotal Scan Failure",
                severity: "High",
                description: "The primary analysis via the VirusTotal API could not be completed. This prevents a comprehensive check for malware, phishing, and other URL-based threats.",
                evidence: vtError,
                remediation: "Please verify that the server's VirusTotal API key is correctly configured and has not exceeded its quota. If the problem persists, check the VirusTotal service status."
            }
        ];

        return { scanReport: JSON.stringify(fallbackReport) };
    }
  }
);
